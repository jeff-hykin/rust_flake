#!/usr/bin/env -S deno run --allow-all
import { FileSystem, glob } from "https://deno.land/x/quickr@0.8.1/main/file_system.js"
import { setSubtract } from 'https://esm.sh/gh/jeff-hykin/good-js@1.17.2.0/source/flattened/set_subtract.js'
import { indent } from 'https://esm.sh/gh/jeff-hykin/good-js@1.17.2.0/source/flattened/indent.js'
// import { jsValueToNix } from "https://esm.sh/gh/jeff-hykin/deno_nix_api@0.1.1.1/tools/basics.js"
import { jsValueToNix } from "https://esm.sh/gh/jeff-hykin/deno_nix_api@6bc1082/tools/basics.js"
var allVersionUrls = (await (await fetch(`https://static.rust-lang.org/manifests.txt`)).text()).trim().split("\n")

var pathToPublishedVersions = `${FileSystem.thisFolder}/published_versions.json`
var publishedVersions = JSON.parse(await FileSystem.read(pathToPublishedVersions))
await FileSystem.write({path:`${FileSystem.thisFolder}/all_versions.json`, data: JSON.stringify(allVersionUrls,0,4), overwrite: true})
// super old versions are not supported by fenix
var allSupportedVersions = []
var markerFound = false
for (let each of allVersionUrls) {
    markerFound = markerFound || each == "static.rust-lang.org/dist/2019-02-28/channel-rust-1.33.0.toml"
    if (markerFound) {
        allSupportedVersions.push(each)
    }
}
var missingVersions = [...setSubtract({value: publishedVersions, from: allSupportedVersions })]
// ex: 
    // static.rust-lang.org/dist/2024-07-13/channel-rust-1.80-beta.toml
    // static.rust-lang.org/dist/2024-07-13/channel-rust-1.80.0-beta.toml
    // static.rust-lang.org/dist/2024-07-13/channel-rust-1.80.0-beta.6.toml

var channels = {}
for (let each of missingVersions) {
    let match
    if (match = each.match(/(\d{4}-\d{2}-\d{2})\/channel-rust-(\d+\.\d+(?:\.\d+)?)?-?(\w+)?(\.\d+)?\.toml$/)) {
        const date = match[1]
        const version = match[2]
        let channel = match[3]
        if (!channel) {
            channel = "version"
        }
        const betaVersion = match[4]
        const url = `https://${each}`
        channels[channel] = channels[channel] ||[]
        const output = {date, url, id: each}
        if (channel == "version") {
            output.version = version
        }
        if (betaVersion) {
            output.betaVersion = betaVersion
        }
        channels[channel].push(output)
        
    } else {
        console.log("no match", each)
    }
}

async function makeFlakeString({channel, version, url, date}) {
    // const supportedSystems = (await (await fetch(url)).text()).split("\n").filter(each=>each.match(/^\[pkg\.cargo\.target\./)).map(each=>each.slice(18,-1))
    // const supportedSystemKeywords = supportedSystems.map(each=>each.split("-"))
    return `{
    # note: this file is autogenerated by https://github.com/jeff-hykin/rust_flake/publisher/publish.js
    description = "Rust versions setup via fenix";

    inputs = {
        flake-utils.url = "github:numtide/flake-utils";
        nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
        fenix.url = "github:nix-community/fenix";
        fenix.inputs.nixpkgs.follows = "nixpkgs";
        rust-manifest = {
            url = ${jsValueToNix(url)};
            flake = false;
        };
    };

    outputs = { self, flake-utils, nixpkgs, fenix, rust-manifest, ... }:
        flake-utils.lib.eachSystem (builtins.attrNames fenix.packages) (system:
            let
                pkgs = import nixpkgs { inherit system; };
                rustToolchain = (fenix.packages.\${system}.fromManifestFile rust-manifest).toolchain;
                rustPlatform = pkgs.makeRustPlatform {
                    cargo = rustToolchain;
                    rustc = rustToolchain;
                };
            in
                {
                    lib = {
                        rustPlatform = rustPlatform // {
                            info = {
                                version = ${jsValueToNix(version)};
                                channel = ${jsValueToNix(channel)};
                                manifestUrl = ${jsValueToNix(url)};
                                date = ${jsValueToNix(date)}; 
                            };
                        };
                    };
                    packages = {
                        rust = rustToolchain;
                    };
                }
        );
}`
}

import $ from "https://esm.sh/@jsr/david__dax@0.43.2/mod.ts"
const $$ = (...args)=>$(...args).noThrow()
// await $$`false`
// (await $$`false`).code
// await $$`false`.text("stderr")
// await $$`false`.text("combined")
// await $$`echo`.stdinText("yes\n")
async function publishFlake({channel, version, url, date, id}) {
    let tagName = `${channel}-${version}`
    if (channel == "version") {
        tagName = `v${version}`
        channel = "stable"
    }
    await FileSystem.write({
        path:`${FileSystem.thisFolder}/../flake.nix`,
        data: await makeFlakeString({channel, version, url, date}),
        overwrite: true
    })
    await $$`git push --delete origin ${tagName}`
    await $$`git tag --delete ${tagName}`
    var {code} = await $$`git add -A && git commit -m ${tagName} && git push && git tag ${tagName} && git push origin ${tagName}`
    var code =0
    const success = code == 0
    // keep track of what has been published
    if (success) {
        // publishedVersions.push(id)
        // await FileSystem.write({path:pathToPublishedVersions, data: JSON.stringify(publishedVersions,0,4), overwrite: true})
        // var {code} = await $$`git add -A && git commit -m ${tagName}`
    }
}

for (const [channel, versions] of Object.entries(channels)) {
    // only edgecase
    if (channel == "version") {
        await $$`git checkout rust_versioned`
        await $$`git merge master`
        for (let { url, id, date, version } of versions) {
            console.debug(`version is:`,version)
            // three numbers are required
            if (version.match(/^\d+\.\d+\.\d+$/)) {
                // must do theses in order
                // console.log({channel, version, url, date, id})
                await publishFlake({channel, version, url, date, id})
            }
            break
        }
    // 
    // publish by date for all non-version channels
    // 
    } else {
        // $$`git checkout -b rust_${channel}`
        // for (let { url, id, date, version } of versions) {
        //     // three numbers are required
        //     if (version.match(/^\d+\.\d+\.\d+$/)) {
        //         console.log({id, version: date.replace(/-/g, "."), date, url})
        //     }
        // }
    }
}
await $$`git checkout master`